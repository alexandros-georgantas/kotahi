// const fs = require('fs')
// const path = require('path')
// const sampleReferenceArray = require('./data/sampleReferences.json')

// const rawData = fs.readFileSync(
//   path.resolve(__dirname, 'data/sampleReferences.txt'),
//   'utf8',
// )

// Assuming that you have anystyle-cli running locally, sample data can be generated by running anystyle-cli locally:
//
//   anystyle -f json,xml parse server/anystyle/data/sampleReferences.txt server/anystyle/data
//
// which will export JSON and XML to server/anystyle/data
//
// If using a different filename, change the filenames in this file for sampleReferenceArray and rawData.
// The XML created this way is interesting but not as detailed as the JSON--look at the author names for example.

// # JATS tags and JATS-flavored HTML equivalents:
//
// <ref-list> —> <section class="reflist">
// <ref id="ref-###"><mixed-citation> --> <p class="mixedcitation" id="ref=###">
//
// AUTHORS
//
// <person-group person-group-type="author"> --> <span class="authorgroup">
// <name> --> <span class="authorname">
// <surname> --> <span class="surname">
// <given-names> --> <span class="givennames">
// <suffix> --> <span class="suffix">
// <etal> --> <span class="etal" />
// <string-name> --> <span class="stringname"> (it would be nice if we didn't have to use this!)
//
// TITLES
//
// <source> ––> <span class="source">
// <article-title> --< <span class="articletitle">
// <volume> --> <span class="volume">
// <fpage> --> <span class="fpage">
// <lpage> --> <span class="lpage">
// <year> --> <span class="year">

const makeStringSafeId = str =>
  encodeURIComponent(str)
    .toLowerCase()
    .replace(/\.|%[0-9a-z]{2}/gi, '')

const anyStyleToHtml = async referenceString => {
  console.log(referenceString)
  const input = referenceString || ''

  const referenceArray = String(input)
    .split('\n')
    .filter(x => x.length)

  let outText = '<section class="reflist">'

  for (let i = 0; i < referenceArray.length; i += 1) {
    const thisRef = referenceArray[i]
    // console.log(
    //   `\n# Citation ${i}:\n`,
    //   'Original reference: `',
    //   arrayOfRawData[i],
    //   '`',
    // )
    console.log('\n```json\n', thisRef, '\n```\n')

    let thisOut = ''

    // 1. deal with citation numbers
    // Query: why does citation-number come in as an array?
    // If we don't have a citation number, we're just sending this back as the index. This is not necessarily unique. Do this in a smarter way?

    console.log(
      `Citation number found for citation ${i}: ${JSON.stringify(
        thisRef['citation-number'],
      )}`,
    )

    const citationNumber =
      thisRef['citation-number'] && thisRef['citation-number'].length
        ? makeStringSafeId(thisRef['citation-number'][0])
        : i + 1

    delete thisRef['citation-number']

    // If type is coming in, add it as a class to the <p class="mixedcitation">

    const type = thisRef.type ? makeStringSafeId(thisRef.type) : ''
    delete thisRef.type

    thisOut += `<p class="mixedcitation type-${type}" id="ref-${citationNumber}">`

    // Deal with authors

    if (thisRef.author) {
      let thisAuthorGroup = `<span class="authorgroup">`

      for (let j = 0; j < thisRef.author.length; j += 1) {
        const thisAuthor = thisRef.author[j]
        let thisAuthorText = `<span class="author">`

        if (thisAuthor.family) {
          thisAuthorText += `<span class="surname">${thisAuthor.family}</span>`
          delete thisAuthor.family
        }

        if (thisAuthor.given) {
          thisAuthorText += `<span class="givennames">${thisAuthor.given}</span>`
          delete thisAuthor.given
        }

        if (thisAuthor.suffix) {
          thisAuthorText += `<span class="suffix">${thisAuthor.suffix}</span>`
          delete thisAuthor.suffix
        }

        thisAuthorText += `</span>`

        if (thisAuthor.others) {
          thisAuthorText = `<span class="etal" />`
          delete thisAuthor.others
        }

        if (thisAuthor.literal) {
          console.log(
            `String-name being used for unstructured author name: ${JSON.stringify(
              thisAuthor,
            )}`,
          )
          thisAuthorText = `<span class="stringname">${thisAuthor.literal}</span>`
          delete thisAuthor.literal
        }

        thisAuthorGroup += thisAuthorText

        if (thisAuthorGroup)
          if (JSON.stringify(thisAuthor).length > 2) {
            console.log(`\nAuthor data: ${JSON.stringify(thisRef.author)}`)
            console.log(`Author ${j} remainder: ${JSON.stringify(thisAuthor)}`)
          }
      }

      thisAuthorGroup += `</span>`
      thisOut += thisAuthorGroup
      delete thisRef.author
    }

    // deal with date
    // ASSUMPTIONS: This is assuming that the date is always a year, and that the first date coming in is the publication date.

    if (thisRef.date && thisRef.date.length) {
      thisOut += `<span class="year">${thisRef.date}</span>`

      if (thisRef.date.length === 1) {
        delete thisRef.date
      } else {
        // In what we have so far, title is always an array of length 1. Just in case, let's throw an error if it's not.
        console.log(
          'Date is longer than expected: ',
          JSON.stringify(thisRef.date),
        )
      }
    }

    // deal with article title

    if (thisRef.title && thisRef.title.length) {
      thisOut += `<span class="articletitle">${thisRef.title[0]}</span>`

      if (thisRef.title.length === 1) {
        delete thisRef.title
      } else {
        // In what we have so far, title is always an array of length 1. Just in case, let's throw an error if it's not.
        console.log(
          'Title is longer than expected: ',
          JSON.stringify(thisRef.title),
        )
      }
    }

    // deal with source title

    if (thisRef['container-title'] && thisRef['container-title'].length) {
      thisOut += `<span class="source">${thisRef['container-title'][0]}</span>`

      if (thisRef['container-title'].length === 1) {
        delete thisRef['container-title']
      } else {
        // In what we have so far, container-title is always an array of length 1. Just in case, let's throw an error if it's not.
        console.log(
          'Container-title is longer than expected: ',
          JSON.stringify(thisRef['container-title']),
        )
      }
    }

    // deal with volume, which comes in as an array for some reason.

    if (thisRef.volume && thisRef.volume.length) {
      thisOut += `<span class="volume">${thisRef.volume[0]}</span>`

      if (thisRef.volume.length === 1) {
        delete thisRef.volume
      } else {
        // In what we have so far, volume is always an array of length 1. Just in case, let's throw an error if it's not.
        console.log(
          'Volume is longer than expected: ',
          JSON.stringify(thisRef.volume),
        )
      }
    }

    // deal with page numbers, which comes in as an array for some reason.

    if (thisRef.pages && thisRef.pages.length) {
      const pageString = thisRef.pages[0].split(/[-,–]/)
      thisOut += `<span class="fpage">${pageString[0]}</span>`

      if (pageString.length > 1) {
        // if here, pages came in as a range
        thisOut += `&ndash;<span class="lpage">${pageString[1]}</span>`

        if (pageString.length > 2) {
          console.log('Pages length is greater than 2!', pageString)
        }
      }

      if (thisRef.pages.length === 1) {
        delete thisRef.pages
      } else {
        // In what we have so far, pages is always an array of length 1. Just in case, let's throw an error if it's not.
        console.log(
          'Pages is longer than expected: ',
          JSON.stringify(thisRef.pages),
        )
      }
    }

    if (Object.keys(thisRef).length) {
      console.log(
        `\n## Unprocessed JSON remainder for citation ${i}:`,
        '\n```json\n',
        thisRef,
        '\n```\n',
      )
    }

    thisOut += JSON.stringify(thisRef)
    thisOut += `</p>`

    console.log(`\n## HTML output:`, '\n````html\n', thisOut, '\n````\n\n')

    outText += thisOut
  }

  outText += '</section>'
  return outText
}

// This is designed for testing anystyle's conversion. To run:
//
// node server/anystyle/anystyleToHtml.js > server/anystyle/output/log.md

// anyStyleToHtml(rawData.split("\n"))

module.exports = anyStyleToHtml
