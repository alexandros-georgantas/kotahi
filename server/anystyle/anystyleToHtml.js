const fs = require('fs')
const path = require('path')
const htmlparser2 = require('htmlparser2')
const cheerio = require('cheerio')
const sampleReferenceArray = require('./data/sampleReferences.json')

const rawData = fs.readFileSync(
  path.resolve(__dirname, 'data/sampleReferences.xml'),
  'utf8',
)

// Assuming that you have anystyle-cli running locally, sample data can be generated by running anystyle-cli locally:
//
//   anystyle -f json,xml parse server/anystyle/data/sampleReferences.txt server/anystyle/data
//
// which will export JSON and XML to server/anystyle/data
//
// If using a different filename, change the filenames in this file for sampleReferenceArray and rawData.
// The XML created this way is interesting but not as detailed as the JSON--look at the author names for example.

// # JATS tags and JATS-flavored HTML equivalents:
//
// <ref-list> —> <section class="reflist">
// <ref id="ref-###"><mixed-citation> --> <p class="mixedcitation" id="ref=###">
//
// AUTHORS
//
// <person-group person-group-type="author"> --> <span class="authorgroup">
// <name> --> <span class="authorname">
// <surname> --> <span class="surname">
// <given-names> --> <span class="givennames">
// <suffix> --> <span class="suffix">
// <etal> --> <span class="etal" />
// <string-name> --> <span class="stringname"> (it would be nice if we didn't have to use this!)
//
// TITLES
//
// <source> ––> <span class="source">
// <article-title> --< <span class="articletitle">
// <volume> --> <span class="volume">
// <fpage> --> <span class="fpage">
// <lpage> --> <span class="lpage">
// <year> --> <span class="year">

const makeStringSafeId = str =>
  encodeURIComponent(str)
    .toLowerCase()
    .replace(/\.|%[0-9a-z]{2}/gi, '')

const anystyleXmlToHtml = (anystyleXml, anystyleJson) => {
  // this takes the XML input from Anystyle and converts it to our HTML
  // maybe we could inject content from the JSON into the HTML if this can be done.
  const dom = htmlparser2.parseDocument(anystyleXml)
  const $ = cheerio.load(dom, { xmlMode: true })

  // 1. replace <dataset> with  <section class="reflist">
  // 2. replace <section> with <p class="mixedcitation" id="ref=###">
  // 2.5. id is coming from <citation-number>, delete <citation-number>
  // 3. replace <author> with <span class="authorgroup">
  // 4. replace <title> with <title>

  // n. strip out all unknown tags, log them

  const outHtml = $.html()
  return outHtml
}

const newAnyStyleToHtml = (textInput, anystyleJson) => {
  // This takes two things:
  // 1) text input which will be split into lines
  // 2) Anystyle JSON created from that text input, which should be an array of the same length as the number of lines

  const textArray = String(textInput)
    .split('\n')
    .filter(x => x.length)

  let outText = '<section class="reflist">'

  for (let i = 0; i < anystyleJson.length; i += 1) {
    const thisAnystyle = anystyleJson[i]
    let thisText = textArray[i]

    // 1. deal with citation numbers
    // Query: why does citation-number come in as an array?
    // If we don't have a citation number, we're just sending this back as the index. This is not necessarily unique. Do this in a smarter way?

    console.log(`\n# Citation ${i}:\n`, 'Original reference: `', thisText, '`')
    console.log('\n```json\n', thisAnystyle, '\n```\n')

    const foundCitationNumber =
      thisAnystyle['citation-number'] && thisAnystyle['citation-number'].length

    console.log(
      `Citation number found for citation ${i}: ${JSON.stringify(
        thisAnystyle['citation-number'],
      )}`,
    )

    const citationNumber = foundCitationNumber
      ? makeStringSafeId(thisAnystyle['citation-number'][0])
      : i + 1

    // If type is coming in, add it as a class to the <p class="mixedcitation">

    const type = thisAnystyle.type ? makeStringSafeId(thisAnystyle.type) : ''
    delete thisAnystyle.type

    let thisOut = `\n<p class="mixedcitation type-${type}" id="ref-${citationNumber}">`

    if (foundCitationNumber) {
      thisOut += `${
        thisText.split(thisAnystyle['citation-number'][0])[0]
      }<span class="citation-number">${
        thisAnystyle['citation-number'][0]
      }</span>`
      thisText = thisText.split(thisAnystyle['citation-number'][0])[1]
      delete thisAnystyle['citation-number']
    }

    if (thisAnystyle.author) {
      console.log('\n# Authors:\n', thisAnystyle.author)
      let authorsBlock

      if (thisAnystyle.author[0].literal) {
        console.log('literal!')
        authorsBlock = thisAnystyle.author[0].literal
      } else {
        // reconstruct our author's block
      }

      console.log("Author's block:", authorsBlock)
    }

    thisOut += thisText
    thisOut += `</p>`
    outText += thisOut
  }

  outText += '</section>'

  return outText
}

const anyStyleToHtml = async (textInput, anystyleJson) => {
  // This takes two things:
  // 1) text input which will be split into lines
  // 2) Anystyle JSON created from that text input, which should be an array of the same length as the number of lines

  const textArray = String(textInput)
    .split('\n')
    .filter(x => x.length)

  let outText = '<section class="reflist">'

  for (let i = 0; i < anystyleJson.length; i += 1) {
    const thisAnystyle = anystyleJson[i]
    const thisText = textArray[i]

    console.log(`\n# Citation ${i}:\n`, 'Original reference: `', thisText, '`')
    console.log('\n```json\n', thisAnystyle, '\n```\n')

    let thisOut = ''

    // 1. deal with citation numbers
    // Query: why does citation-number come in as an array?
    // If we don't have a citation number, we're just sending this back as the index. This is not necessarily unique. Do this in a smarter way?

    console.log(
      `Citation number found for citation ${i}: ${JSON.stringify(
        thisAnystyle['citation-number'],
      )}`,
    )

    const citationNumber =
      thisAnystyle['citation-number'] && thisAnystyle['citation-number'].length
        ? makeStringSafeId(thisAnystyle['citation-number'][0])
        : i + 1

    delete thisAnystyle['citation-number']

    // If type is coming in, add it as a class to the <p class="mixedcitation">

    const type = thisAnystyle.type ? makeStringSafeId(thisAnystyle.type) : ''
    delete thisAnystyle.type

    thisOut += `<p class="mixedcitation type-${type}" id="ref-${citationNumber}">`

    // Deal with authors

    if (thisAnystyle.author) {
      let thisAuthorGroup = `<span class="authorgroup">`

      for (let j = 0; j < thisAnystyle.author.length; j += 1) {
        const thisAuthor = thisAnystyle.author[j]
        let thisAuthorText = `<span class="author">`

        if (thisAuthor.family) {
          thisAuthorText += `<span class="surname">${thisAuthor.family}</span>`
          delete thisAuthor.family
        }

        if (thisAuthor.given) {
          thisAuthorText += `<span class="givennames">${thisAuthor.given}</span>`
          delete thisAuthor.given
        }

        if (thisAuthor.suffix) {
          thisAuthorText += `<span class="suffix">${thisAuthor.suffix}</span>`
          delete thisAuthor.suffix
        }

        thisAuthorText += `</span>`

        if (thisAuthor.others) {
          thisAuthorText = `<span class="etal" />`
          delete thisAuthor.others
        }

        if (thisAuthor.literal) {
          console.log(
            `String-name being used for unstructured author name: ${JSON.stringify(
              thisAuthor,
            )}`,
          )
          thisAuthorText = `<span class="stringname">${thisAuthor.literal}</span>`
          delete thisAuthor.literal
        }

        thisAuthorGroup += thisAuthorText

        if (thisAuthorGroup)
          if (JSON.stringify(thisAuthor).length > 2) {
            console.log(`\nAuthor data: ${JSON.stringify(thisAnystyle.author)}`)
            console.log(`Author ${j} remainder: ${JSON.stringify(thisAuthor)}`)
          }
      }

      thisAuthorGroup += `</span>`
      thisOut += thisAuthorGroup
      delete thisAnystyle.author
    }

    // deal with date
    // ASSUMPTIONS: This is assuming that the date is always a year, and that the first date coming in is the publication date.

    if (thisAnystyle.date && thisAnystyle.date.length) {
      thisOut += `<span class="year">${thisAnystyle.date}</span>`

      if (thisAnystyle.date.length === 1) {
        delete thisAnystyle.date
      } else {
        // In what we have so far, title is always an array of length 1. Just in case, let's throw an error if it's not.
        console.log(
          'Date is longer than expected: ',
          JSON.stringify(thisAnystyle.date),
        )
      }
    }

    // deal with article title

    if (thisAnystyle.title && thisAnystyle.title.length) {
      thisOut += `<span class="articletitle">${thisAnystyle.title[0]}</span>`

      if (thisAnystyle.title.length === 1) {
        delete thisAnystyle.title
      } else {
        // In what we have so far, title is always an array of length 1. Just in case, let's throw an error if it's not.
        console.log(
          'Title is longer than expected: ',
          JSON.stringify(thisAnystyle.title),
        )
      }
    }

    // deal with source title

    if (
      thisAnystyle['container-title'] &&
      thisAnystyle['container-title'].length
    ) {
      thisOut += `<span class="source">${thisAnystyle['container-title'][0]}</span>`

      if (thisAnystyle['container-title'].length === 1) {
        delete thisAnystyle['container-title']
      } else {
        // In what we have so far, container-title is always an array of length 1. Just in case, let's throw an error if it's not.
        console.log(
          'Container-title is longer than expected: ',
          JSON.stringify(thisAnystyle['container-title']),
        )
      }
    }

    // deal with volume, which comes in as an array for some reason.

    if (thisAnystyle.volume && thisAnystyle.volume.length) {
      thisOut += `<span class="volume">${thisAnystyle.volume[0]}</span>`

      if (thisAnystyle.volume.length === 1) {
        delete thisAnystyle.volume
      } else {
        // In what we have so far, volume is always an array of length 1. Just in case, let's throw an error if it's not.
        console.log(
          'Volume is longer than expected: ',
          JSON.stringify(thisAnystyle.volume),
        )
      }
    }

    // deal with page numbers, which comes in as an array for some reason.

    if (thisAnystyle.pages && thisAnystyle.pages.length) {
      const pageString = thisAnystyle.pages[0].split(/[-,–]/)
      thisOut += `<span class="fpage">${pageString[0]}</span>`

      if (pageString.length > 1) {
        // if here, pages came in as a range
        thisOut += `&ndash;<span class="lpage">${pageString[1]}</span>`

        if (pageString.length > 2) {
          console.log('Pages length is greater than 2!', pageString)
        }
      }

      if (thisAnystyle.pages.length === 1) {
        delete thisAnystyle.pages
      } else {
        // In what we have so far, pages is always an array of length 1. Just in case, let's throw an error if it's not.
        console.log(
          'Pages is longer than expected: ',
          JSON.stringify(thisAnystyle.pages),
        )
      }
    }

    if (Object.keys(thisAnystyle).length) {
      console.log(
        `\n## Unprocessed JSON remainder for citation ${i}:`,
        '\n```json\n',
        thisAnystyle,
        '\n```\n',
      )
    }

    thisOut += JSON.stringify(thisAnystyle)
    thisOut += `</p>`

    console.log(`\n## HTML output:`, '\n````html\n', thisOut, '\n````\n\n')

    outText += thisOut
  }

  outText += '</section>'

  console.log(`\n\n\n## Final HTML:\n`, outText)
  return outText
}

// This is designed for testing anystyle's conversion. To run:
//
// node server/anystyle/anystyleToHtml.js > server/anystyle/output/log.md

// anyStyleToHtml(rawData, sampleReferenceArray)
console.log(anystyleXmlToHtml(rawData, sampleReferenceArray))

module.exports = anyStyleToHtml
